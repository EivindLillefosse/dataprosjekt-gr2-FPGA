#!/usr/bin/env tclsh
# Dump IP CONFIG.* properties for a given IP instance into YAML
# Usage inside Vivado Tcl console (project open):
#   source scripts/dump_ip_config.tcl
#   dump_ip_config fifo_generator_0 scripts/ip_manifests/fifo_generator_0_full.yaml

proc dump_ip_config {ip_instance out_file} {
    if {[llength [get_ips $ip_instance]] == 0} {
        puts "ERROR: IP instance '$ip_instance' not found. Use get_ips to list available IPs."
        return
    }

    set ipobj [lindex [get_ips $ip_instance] 0]
    set props [list_property $ipobj]

    # filter for CONFIG.* entries
    set config_props {}
    foreach p $props {
        if {[string match CONFIG.* $p]} { lappend config_props $p }
    }

    # Gather values
    set out_lines {}
    lappend out_lines "# Generated by dump_ip_config.tcl"
    lappend out_lines "id: $ip_instance"
    lappend out_lines "config:"
    foreach cp $config_props {
        set val [get_property $cp $ipobj]
        # quote strings
        if {[string is double -strict $val]} {
            set val "\"$val\""
        }
        lappend out_lines "  $cp: $val"
    }

    # write file
    set fh [open $out_file w]
    foreach l $out_lines { puts $fh $l }
    close $fh
    puts "Wrote $out_file with [llength $config_props] CONFIG entries."
}

proc dump_all_ips {out_dir {skip_prefixes {layer}}} {
    # skip_prefixes: a Tcl list of prefixes to skip (default: {layer})
    if {![file isdirectory $out_dir]} {
        # try to create directory
        if {[catch {file mkdir $out_dir} err]} {
            puts "ERROR: cannot create output directory '$out_dir': $err"
            return
        }
    }

    set dumped 0
    set skipped 0
    set ip_list [get_ips]
    foreach ip $ip_list {
        set name [lindex $ip 0]
        # Check skip prefixes
        set do_skip 0
        foreach pref $skip_prefixes {
            if {[string match "${pref}*" $name]} {
                set do_skip 1
                break
            }
        }
        if {$do_skip} {
            incr skipped
            continue
        }
        set file [file join $out_dir "${name}_config.yaml"]
        if {[catch {dump_ip_config $name $file} err]} {
            puts "Warning: failed to dump $name : $err"
        } else {
            incr dumped
        }
    }
    puts "Dumped $dumped IP(s). Skipped $skipped IP(s) matching prefixes: $skip_prefixes"
}

puts "dump_ip_config.tcl loaded. Use 'dump_ip_config <ip_name> <out_file>' or 'dump_all_ips <out_dir>'"

# ============================================================================
# Apply manifests: read YAML files and create/update IPs in ip_repo
# ============================================================================
proc apply_ip_manifests {manifests_dir {ip_repo_dir "./ip_repo"}} {
    if {![file isdirectory $manifests_dir]} {
        puts "ERROR: manifests directory not found: $manifests_dir"
        return
    }

    foreach f [glob -nocomplain "$manifests_dir/*_config.yaml"] {
        puts "Processing manifest: $f"
        set fh [open $f r]
        set content [read $fh]
        close $fh
        set lines [split $content "\n"]

        set ipname ""
        set in_config 0
        set kv {}
        foreach l $lines {
            set line [string trim $l]
            if {$line == ""} { continue }
            if {[string index $line 0] == "#"} { continue }
            if {[regexp {^id:\s*(\S+)} $line -> id]} {
                set ipname $id
                continue
            }
            if {$line == "config:"} {
                set in_config 1
                continue
            }
            if {$in_config} {
                # Expect: <PROP>: <VALUE>
                if {[regexp {^([^:]+):\s*(.*)$} $line -> key val]} {
                    set key [string trim $key]
                    set val [string trim $val]
                    # strip surrounding quotes if present
                    if {[regexp {^"(.*)"$} $val -> qq]} { set val $qq }
                    # append key/value
                    lappend kv $key $val
                }
            }
        }

        if {$ipname == ""} {
            puts "Warning: no 'id' found in manifest $f - skipping"
            continue
        }

        # create ip if missing
        set created_new 0
        if {[llength [get_ips $ipname]] == 0} {
            # infer ip core name from ipname (strip trailing _N)
            if {[regexp {^([a-zA-Z0-9_]+)_(\d+)$} $ipname -> base idx]} {
                set ipcore $base
            } else {
                set ipcore $ipname
            }
            puts "Creating IP instance '$ipname' (core: $ipcore) in $ip_repo_dir"
            if {[catch {create_ip -name $ipcore -vendor xilinx.com -library ip -module_name $ipname -dir $ip_repo_dir} err]} {
                puts "ERROR: failed to create IP $ipname : $err"
                continue
            }
            set created_new 1
        } else {
            puts "IP instance '$ipname' already exists - checking for changed properties"
        }

        # prepare to apply only changed properties
        set ipobj [lindex [get_ips $ipname] 0]
        set changes 0
        set dictlist [list]
        for {set i 0} {$i < [llength $kv]} {incr i 2} {
            set k [lindex $kv $i]
            set v [lindex $kv [expr {$i+1}]]
            # if newly created, just add
            if {$created_new} {
                lappend dictlist $k $v
                incr changes
                continue
            }
            # otherwise compare current property value
            if {[catch {set cur [get_property $k $ipobj]} err]} {
                # if we can't read it, include it so we attempt to set
                lappend dictlist $k $v
                incr changes
            } else {
                # normalize empty vs { }
                if {$cur ne $v} {
                    lappend dictlist $k $v
                    incr changes
                }
            }
        }

        if {$changes > 0} {
            if {[catch {set_property -dict $dictlist $ipobj} err]} {
                puts "Warning: failed to set properties on $ipname : $err"
            } else {
                puts "Updated $changes property(ies) on $ipname"
            }
        } else {
            puts "No property changes detected for $ipname"
        }

        # generate outputs only if created new or there were changes
        if {$created_new || $changes > 0} {
            if {[catch {generate_target all [get_files [get_property IP_FILE $ipobj]]} err]} {
                puts "Warning: failed to generate IP outputs for $ipname : $err"
            } else {
                puts "Generated output products for $ipname"
            }
        } else {
            puts "Skipping IP generation for $ipname (no changes)"
        }
    }
}
