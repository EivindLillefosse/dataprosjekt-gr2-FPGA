#!/usr/bin/env tclsh
# Dump IP CONFIG.* properties for a given IP instance into YAML

proc dump_ip_config {ip_instance out_file} {
    if {[llength [get_ips $ip_instance]] == 0} {
        puts "ERROR: IP instance '$ip_instance' not found."
        return
    }
    set ipobj [lindex [get_ips $ip_instance] 0]

    # Collect IP metadata
    set metadata [dict create]

    # Get the IPDEF property from the IP instance - this IS the VLNV!
    # Format: "vendor:library:name:version" (e.g., "xilinx.com:ip:blk_mem_gen:8.4")
    if {[catch {set ipdef_name [get_property IPDEF $ipobj]} err]} {
        puts "  Warning: Cannot get IPDEF for $ip_instance: $err"
        set ipdef_name "unknown"
    }

    # The IPDEF property value IS the VLNV string
    dict set metadata VLNV $ipdef_name

    # Parse VLNV if valid (Vendor:Library:Name:Version format)
    if {$ipdef_name != "unknown" && [string match "*:*:*:*" $ipdef_name]} {
        set vlnv_parts [split $ipdef_name ":"]
        dict set metadata vendor [lindex $vlnv_parts 0]
        dict set metadata library [lindex $vlnv_parts 1]
        dict set metadata core_name [lindex $vlnv_parts 2]
        dict set metadata version [lindex $vlnv_parts 3]
        puts "  Parsed VLNV: [dict get $metadata vendor]:[dict get $metadata library]:[dict get $metadata core_name]:[dict get $metadata version]"
    } else {
        puts "  Warning: IPDEF not in expected VLNV format: $ipdef_name"
    }

    # Fallback: try to get properties directly from IP instance
    if {![dict exists $metadata VLNV] || [dict get $metadata VLNV] == "unknown"} {
        foreach prop {NAME VERSION_MAJOR VERSION_MINOR} {
            if {[catch {set val [get_property $prop $ipobj]} err]} {
                dict set metadata $prop "unknown"
            } else {
                dict set metadata $prop $val
            }
        }
    }

    # Get all CONFIG.* properties
    set props [list_property $ipobj]
    set config_props {}
    foreach p $props {
        if {[string match CONFIG.* $p]} { lappend config_props $p }
    }

    # Build output
    set out_lines {}
    lappend out_lines "# Generated by dump_ip_config.tcl"
    lappend out_lines "# IP Core Metadata:"
    if {[dict exists $metadata vendor]} {
        lappend out_lines "#   Vendor: [dict get $metadata vendor]"
    }
    if {[dict exists $metadata library]} {
        lappend out_lines "#   Library: [dict get $metadata library]"
    }
    if {[dict exists $metadata core_name]} {
        lappend out_lines "#   Core Name: [dict get $metadata core_name]"
    }
    if {[dict exists $metadata version]} {
        lappend out_lines "#   Version: [dict get $metadata version]"
    }
    lappend out_lines "#   VLNV: [dict get $metadata VLNV]"
    lappend out_lines ""
    lappend out_lines "id: $ip_instance"

    # Add metadata section
    lappend out_lines "metadata:"
    if {[dict exists $metadata vendor]} {
        lappend out_lines "  vendor: \"[dict get $metadata vendor]\""
    }
    if {[dict exists $metadata library]} {
        lappend out_lines "  library: \"[dict get $metadata library]\""
    }
    if {[dict exists $metadata core_name]} {
        lappend out_lines "  name: \"[dict get $metadata core_name]\""
    }
    if {[dict exists $metadata version]} {
        lappend out_lines "  version: \"[dict get $metadata version]\""
    }
    lappend out_lines "  vlnv: \"[dict get $metadata VLNV]\""

    lappend out_lines "config:"
    foreach cp $config_props {
        set val [get_property $cp $ipobj]
        if {[string first " " $val] >= 0 || ![string is double -strict $val]} {
            set val "\"$val\""
        }
        lappend out_lines "  $cp: $val"
    }
    set fh [open $out_file w]
    foreach l $out_lines { puts $fh $l }
    close $fh
    puts "Wrote $out_file with [llength $config_props] CONFIG entries + metadata."
}

proc dump_all_ips {out_dir {skip_prefixes {layer}}} {
    if {![file isdirectory $out_dir]} {
        if {[catch {file mkdir $out_dir} err]} {
            puts "ERROR: cannot create output directory '$out_dir': $err"
            return
        }
    }
    set dumped 0
    set skipped 0
    set ip_list [get_ips]
    foreach ip $ip_list {
        set name [lindex $ip 0]
        set do_skip 0
        foreach pref $skip_prefixes {
            if {[string match "${pref}*" $name]} {
                set do_skip 1
                break
            }
        }
        if {$do_skip} {
            incr skipped
            continue
        }
        set file [file join $out_dir "${name}_config.yaml"]
        if {[catch {dump_ip_config $name $file} err]} {
            puts "Warning: failed to dump $name : $err"
        } else {
            incr dumped
        }
    }
    puts "Dumped $dumped IP(s). Skipped $skipped IP(s) matching prefixes: $skip_prefixes"
}

proc normalize_val {v} {
    set v [string trim $v]
    if {[regexp {^\{(.*)\}$} $v -> inner]} {
        set v [string trim $inner]
    }
    if {[string tolower $v] == "true"} { return "true" }
    if {[string tolower $v] == "false"} { return "false" }
    if {[regexp {^"(.*)"$} $v -> q]} { set v $q }
    return $v
}

proc apply_ip_manifests {manifests_dir {ip_repo_dir "./ip_repo"} {dry_run 0}} {
    if {![file isdirectory $manifests_dir]} {
        puts "ERROR: manifests directory not found: $manifests_dir"
        return
    }
    set files [glob -nocomplain "$manifests_dir/*_config.yaml"]
    if {[llength $files] == 0} {
        puts "No YAML manifest files found in $manifests_dir"
        return
    }
    foreach f $files {
        puts "Processing manifest: $f"
        set fh [open $f r]
        set content [read $fh]
        close $fh
        set ipname ""
        set kv_list [list]
        foreach line [split $content "\n"] {
            set l [string trim $line]
            if {$l == "" || [string index $l 0] == "#"} continue
            if {[regexp {^id:\s*(.+)$} $l -> idval]} {
                set ipname [string trim $idval]
                continue
            }
            if {[regexp {^\s*(CONFIG\.[^:]+):\s*(.+)$} $l -> key val]} {
                lappend kv_list [string trim $key] [string trim $val]
            }
        }
        if {$ipname == ""} {
            puts "  Warning: no id found in $f, skipping"
            continue
        }
        set ip_exists [expr {[llength [get_ips $ipname]] > 0}]
        set created_new 0
        if {!$ip_exists} {
            if {$dry_run} {
                puts "DRY-RUN: Would create IP '$ipname' with [expr {[llength $kv_list]/2}] properties"
                continue
            }
            if {[regexp {^([a-zA-Z0-9_]+)_(\d+)$} $ipname -> base idx]} {
                set ipcore $base
            } else {
                set ipcore $ipname
            }
            puts "  Creating IP instance '$ipname' (core: $ipcore) in $ip_repo_dir"
            if {[catch {create_ip -name $ipcore -vendor xilinx.com -library ip -module_name $ipname -dir $ip_repo_dir} err]} {
                puts "  ERROR: failed to create IP $ipname : $err"
                continue
            }
            set created_new 1
        } else {
            puts "  IP instance '$ipname' already exists - checking properties"
        }
        set ipobj [lindex [get_ips $ipname] 0]
        set dictlist [list]
        set changes 0
        for {set i 0} {$i < [llength $kv_list]} {incr i 2} {
            set k [lindex $kv_list $i]
            set vraw [lindex $kv_list [expr {$i+1}]]
            set v [normalize_val $vraw]
            if {$created_new} {
                lappend dictlist $k $v
                incr changes
                continue
            }
            if {[catch {set cur [get_property $k $ipobj]} err]} {
                lappend dictlist $k $v
                incr changes
            } else {
                set cur_norm [normalize_val $cur]
                if {$cur_norm ne $v} {
                    lappend dictlist $k $v
                    incr changes
                }
            }
        }
        if {$changes > 0} {
            if {$dry_run} {
                puts "DRY-RUN: Would update $changes property(ies) on $ipname"
            } else {
                if {[catch {set_property -dict $dictlist $ipobj} err]} {
                    puts "  Warning: failed to set properties on $ipname : $err"
                } else {
                    puts "  Updated $changes property(ies) on $ipname"
                }
            }
        } else {
            puts "  No property changes detected for $ipname"
        }
        if {!$dry_run && ($created_new || $changes > 0)} {
            if {[catch {generate_target all [get_files [get_property IP_FILE $ipobj]]} err]} {
                puts "  Warning: failed to generate IP outputs for $ipname : $err"
            } else {
                puts "  Generated output products for $ipname"
            }
        } elseif {$dry_run && ($created_new || $changes > 0)} {
            puts "DRY-RUN: Would generate output products for $ipname"
        }
    }
    puts "apply_ip_manifests complete"
}

puts "dump_ip_config.tcl loaded. Use 'dump_ip_config <ip_name> <out_file>' or 'dump_all_ips <out_dir>'"
